<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Comprehensible Comprehensions</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <!-- 2 minute section -->
      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Comprehensible Comprehensions</h1>
          <p>
          <small><a href="https://treyhunner.com" rel="author">Trey Hunner</a> / Python &amp; Django Trainer / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            - My name is Trey.  I do corporate Python training for a living.
            - I'm hoping to share with you my love of a particular Python feature that is often misunderstood and misused.
          </aside>
        </section>

        <section>
          <h2>Assumptions</h2>
          <ul>
            <li>You know how <code>for</code> loops work in Python</li>
            <li>You're not already a big fan of list comprehensions and generator expressions</li>
          </ul>
          <aside class="notes" data-markdown>
            - During this talk, I'm assuming you know how `for` loops work in Python
            - I'm also assuming you're **not** already a fan of list comprehensions and generator expressions
            - I hope to make you a fan of both by the end this talk
          </aside>
        </section>

        <section>
          <h2>Definitions</h2>
          <ul>
            <li><strong>iterable</strong>: anything you can loop over</li>
            <li><strong>list comprehension</strong>: for making a new list from an iterable</li>
            <li><strong>generator</strong>: for making a "lazy" (pause-able) iterable</li>
          </ul>
          <aside class="notes" data-markdown>
            - Before we get started, let's start with some definitions
            - An **iterable** is anything you can iterate over.  So anything you can loop over with a `for` loop is an iterable.
            - Lists are iterables, dictionaries are iterables, sets are iterables, strings are iterables... lots of things in Python are iterables
            - A **list comprehension** is a special syntax for making a new list from any iterable
            - A **generator** is a lazy iterable.  Generators pause and restart themselves repeatedly as you loop over them.
            - A **generator expression** is a special syntax for making a generator
          </aside>
        </section>

        <section>
          <h2>What are comprehensions?</h2>
          <p><blockquote>List comprehensions are a special syntax for turning one list into another list</blockquote></p>
          <aside class="notes" data-markdown>
            - I'll be discussing all of those terms, but the term we're *primarily* focused on is **list comprehensions**
            - List comprehensions do not solve a new problem...
            - They're *special-purpose* tools for solving a problem we're already able to solve with `for` loops: turning one list into another list
          </aside>
        </section>

      </section>

      <!-- 5 minute section -->
      <section>

        <section>
          <h2>Turning Old Lists Into New Lists</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's talk about `for` loops
          </aside>
        </section>

        <section>
          <h2><code>for</code> loops</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = [1, 2, 3, 4, 5]

# Print out square of odd numbers
for n in numbers:
    if n % 2 == 1:
        print(n ** 2)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Python's `for` allows us to loop over any iterable and do things with each item as we loop
            - We can put `if` statements, `print` functions, or pretty much any other code inside our `for` loops
          </aside>
        </section>

        <section>
          <h2>Turning lists into lists</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = [1, 2, 3, 4, 5]

# Populate new list with square of odd numbers
squared_odds = []
for n in numbers:
    if n % 2 == 1:
        squared_odds.append(n ** 2)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This `for` loop makes a new list 
            - Making one list from another list is a *really* common thing to do in Python, even more common than many other programming languages
            - Turning old lists to new lists is common in other languages, but it is particularly common in Python
            - Why is making new lists from old lists so common in Python in particular?
            - I'm going to take a little aside here to talk about the reason we turn old lists into new lists so often in Python
          </aside>
        </section>

        <section>
          <h2>Variables Are References</h2>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
>>> old = [1, 2, 3]
>>> new = old
>>> new.pop()
>>> new
[1, 2]
<span class="error">>>> old
[1, 2]</span>

<div class="fragment">>>> old = [1, 2, 3]
>>> new = old[:-1]
>>> new
[1, 2]
<span class="success">>>> old
[1, 2, 3]</span></div>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Assigning to a variable in Python doesn't copy anything
            - Variables in Python are not buckets containing objects
            - Variables are simply *references* to objects
            - This can really trip up new Python programmers
            - So we tend to copy old lists to new lists because *mutating* lists is often a bad idea
            - When we modify a list, every other variable that points to that same list will seem to change as well
          </aside>
        </section>

        <section>
          <h2>Turning lists into lists</h2>
          <p>
          <pre class="python"><code data-trim>
squared_odds = []
for n in numbers:
    if n % 2 == 1:
        squared_odds.append(n ** 2)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So turning old lists into new lists is a very common thing to do
            - It's such a common thing to do that Python developers added a special syntax just for turning one list into another list
            - This special syntax is called a list comprehension
          </aside>
        </section>

        <section>
          <h2>With comprehensions</h2>
          <p>
          <pre class="python"><code data-trim>
squared_odds = [n ** 2 for n in numbers if n % 2 == 1]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This list comprehension is equivalent to that `for` loop we wrote before
            - This list comprehension is *very* information-dense
            - We've condensed four lines of code into one line here
            - Let's break down our `for` loop and our comprehension to see how they compare
          </aside>
        </section>

        <section>
          <h2>Breaking it down</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs">
<span class="new-collection">squared_odds</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span>:
    <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>:
        <span class="new-collection">squared_odds</span>.append(<span class="item-mutation">n ** 2</span>)
          </code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs">
<span class="new-collection">squared_odds</span> = <span class="collection-type">[</span><span class="item-mutation">n ** 2</span> <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span><span class="collection-type"> <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>]</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - I've here highlighted five things in this `for` loop
              - The variable name for our new list is in green
              - The square brackets that make our list are in dark red
              - The looping logic is in purple
              - The condition is in bright red
              - And the item we're appending every time we loop is in blue
            - Here are the same items highlighted in our comprehension
            - Notice that our comprehension contains pretty much the same information as our `for` loop except that:
              - we aren't repeating the variable name
              - and we don't have to type append
            - Loops and list comprehensions are so similar that you can copy-paste your way from a `for` loop to a comprehension
          </aside>
        </section>

        <section>
          <h2>Copy-pasting into a comprehension</h2>
          <img src="list-comprehension-condition.gif" class="no-style">
          <aside class="notes" data-markdown>
            - First we copy the assignment
            - Then we copy thing we're appending
            - Then we copy the looping logic
            - Then we copy our condition
            - And after that we've copy pasted our way a `for` loop to a list comprehension
            - So we just need to copy each those components from the `for` loop into a comprehension and we can build a comprehension up without actually typing anything new
          </aside>
        </section>

        <section>
          <h2>You can always copy-paste</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span>:
    <span class="conditional-clause">if <span class="condition">condition(item)</span></span>:
        <span class="new-collection">new_list</span>.append(<span class="item-mutation">operation(item)</span>)</code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span><span class="item-mutation">operation(item)</span> <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">old_list</span></span><span class="collection-type"> <span class="conditional-clause">if <span class="condition">condition(item)</span></span>]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here I've highlighted the same five things I was highlighting before
            - This `for` loop is generic code though... it's a blueprint
            - As long as you can figure out a way to write your for loop in this format, you can always copy-paste your way from a `for` loop to a comprehension
            - So I've shown you how to build a list comprehension from a `for` loop... let's talk about readability
          </aside>
        </section>

      </section>

      <!-- 2 minute section -->
      <section>

        <section>
          <h2>Readability</h2>
          <ul>
          <aside class="notes" data-markdown>
            - The most common complaint about list comprehensions is that they're hard to read
            - List comprehensions tend to be more compact than `for` loops
            - Let's talk about that
          </aside>
        </section>

        <section>
          <h2>But they're not readable</h2>
          <p>
          <pre class="python"><code data-trim>
for n in numbers:
    if n % 2 == 1:
        squared_odds.append(n ** 2)
          </code></pre>
          <pre class="python"><code data-trim>
squared_odds = [n ** 2 for n in numbers if n % 2 == 1]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Comprehensions are often written all on one line
            - That can make comprehensions hard to read
            - The comprehension here has less unnecessary information than the `for` loop, but it also has **less whitespace**
          </aside>
        </section>

        <section data-transition="slide-in none-out">
          <h2>Breaking up the components</h2>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[</span><span class="item-mutation">n ** 2</span> <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span><span class="collection-type"> <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>]</span>
          </code></pre>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[</span>
    <span class="item-mutation">n ** 2</span>
    <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span><span class="collection-type">
    <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Comprehensions have 3 parts: the operation, the loop, and the condition
            - There's no reason that all of those three parts have to be written on one line of code
            - In Python, whenever an open bracket, brace, or parenthesis, you can insert line breaks to break one line of code over multiple lines
            - Breaking comprehensions into three lines can make them much more readable
          </aside>
        </section>

        <section data-transition="none-in slide-out">
          <h2>Breaking up the components</h2>
          <p>
          <pre class="python"><code data-trim>
squared_odds = [n ** 2 for n in numbers if n % 2 == 1]
          </code></pre>
          <pre class="python"><code data-trim>
squared_odds = [
    n ** 2
    for n in numbers
    if n % 2 == 1
]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - In fact, I would say that breaking up a comprehension over multiple lines almost always improves readability
            - So I would recommend writing the **majority** of your list comprehensions using multiple lines
          </aside>
        </section>

        <section data-transition="slide-in none-out">
          <h2>They can be more readable</h2>
          <p>
          <pre class="python"><code data-trim>
squared_odds = []
for n in numbers:
    if n % 2 == 1:
        squared_odds.append(n ** 2)
          </code></pre>
          <pre class="python"><code data-trim>
squared_odds = [
    n ** 2
    for n in numbers
    if n % 2 == 1
]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Note that this multi-line list comprehension hasn't saved us any lines of code
            - In fact, we've gone from 4 lines of code in our `for` loop to 5 lines of code in our list comprehension
            - List comprehensions are **not** about saving lines of code
            - List comprehensions are for making our code more descriptive and more readable
          </aside>
        </section>

        <section data-transition="none-in slide-out">
          <h2>They can be more readable</h2>
          <p>
          <pre class="python"><code data-trim data-noescape>
<span class="blur">squared_odds = []</span>
for <span class="blur">n</span> in <span class="blur">squared_odds</span>:
    <span class="blur">if n % 2 == 1:
        squared_odds.append(n ** 2)</span>
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
squared_odds = [
    <span class="blur">n ** 2</span>
    for <span class="blur">n</span> in <span class="blur">numbers</span>
    <span class="blur">if n % 2 == 1</span>
]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - When a reader looks at the `for` loop above it's obvious that we're looping... but it *may not* be immediately obvious *why* we're looping
            - When a reader sees our comprehension, it should be immediately obvious that **we're creating one loop from another loop**
            - When we use a list comprehension, we're being more specific with the intent of our code: we're *not* just looping, we're making *one list* out of *another list*
          </aside>
        </section>

      </section>

      <!-- 3 minute section -->
      <section>

        <section>
          <h2>But wait... there's more!</h2>
          <ul>
          <aside class="notes" data-markdown>
            - So I've glossed over a few important details in the world of list comprehensions
            - So let's look at a few other ways that you can make list comprehensions
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <h2>With Filtering</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span>:
    <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>:
        <span class="new-collection">squared_odds</span>.append(<span class="item-mutation">n ** 2</span>)</code></pre>
          </p>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[</span>
    <span class="item-mutation">n ** 2</span>
    <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span><span class="collection-type">
    <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This whole time I've been showing you list comprehensions with a condition
            - These list comprehensions *filter out* items that don't match a certain condition
            - You can also write list comprehensions without this `if` statement
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <h2>Without Filtering</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_numbers</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span>:
    <span class="new-collection">squared_numbers</span>.append(<span class="item-mutation">n ** 2</span>)
          </code></pre>
          </p>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_numbers</span> = <span class="collection-type">[</span>
    <span class="item-mutation">n ** 2</span>
    <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span>
<span class="collection-type">]</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're not filtering our list down at all, we're simply changing each item
            - So our `for` loop doesn't have an `if` statement and our list comprehension doesn't have a condition
            - Note that you can still copy-paste your way from that `for` loop to this comprehension
            - List comprehensions can be used for filtering, mapping, or both.  This one is just for mapping old values to new values.
          </aside>
        </section>

        <section>
          <h2>With Multiple Loops</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">flattened</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">row</span> in <span class="old-collection">matrix</span></span>:
    <span class="nested-for-loop">for <span class="item">n</span> in <span class="old-collection">row</span></span>:
        <span class="new-collection">flattened</span>.append(<span class="item-mutation">n</span>)</code></pre>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">flattened</span> = <span class="collection-type">[</span>
    <span class="item-mutation">n</span>
    <span class="for-loop">for <span class="item">row</span> in <span class="old-collection">matrix</span></span><span class="collection-type">
    <span class="nested-for-loop">for <span class="item">n</span> in <span class="old-collection">row</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - You can also put multiple `for` loops in a comprehension
            - Here we're looping into a list of lists and flattening it into a single list
            - Putting multiple `for` clauses in a comprehension can get a little complicated so be careful about using this
            - If you are going to do this, definitely make sure you break up your comprehension over multiple lines
          </aside>
        </section>

        <section>
          <h2>Set comprehensions</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = {1, 2, 3, 4, 5}

squared_odds = set()
for n in numbers:
    if n % 2 == 1:
        squared_odds.add(n ** 2)
          </code></pre>
          <pre class="python"><code data-trim>
numbers = {1, 2, 3, 4, 5}

squared_odds = {
    n ** 2
    for n in numbers
    if n % 2 == 1
}
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Comprehensions aren't just limited to lists... there are also set comprehensions
            - Just as a list comprehension builds up a new list, a set comprehension builds up a new set
            - Set comprehensions are functionally equivalent to adding items to a set over and over in a loop (just as list comprehensions are functionally equivalent to appending items to a list over and over)
          </aside>
        </section>

        <section>
          <h2>Dictionary comprehensions</h2>
          <p>
          <pre class="python"><code data-trim>
from string import ascii_lowercase

letter_positions = {}
for n, letter in enumerate(ascii_lowercase, start=1):
    letter_positions[letter] = n
          </code></pre>
          <pre class="python"><code data-trim>
from string import ascii_lowercase

letter_positions = {
    letter: n
    for n, letter in enumerate(ascii_lowercase, start=1)
}
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So there's set comprehensions... there's also dictionary comprehensions
            - List comprehensions make lists, set comprehensions make sets, and dictionary comprehensions make dictionaries
            - Just as sets and dictionaries have a similar syntax, dictionary comprehensions and set comprehensions have a similar syntax
            - Dictionary comprehensions use curly braces the same way that set comprehensions do
            - But unlike set comprehensions they need a colon in-between key-value pairs to build up the dictionary
          </aside>
        </section>

      </section>

      <!-- 7 minute section -->
      <section>

        <section>
          <h2>Examples</h2>
          <aside class="notes" data-markdown>
            - So I've shown you the syntax of list, set, and dictionary comprehensions
            - Let's take a look at some slightly more realistic examples of list, set, and dictionary comprehensions
          </aside>
        </section>

        <section>
          <h2>Modifying each item in a list</h2>
          <pre class="python"><code data-trim>
lowercased_words = [word.lower() for word in words]
          </code></pre>
          <aside class="notes" data-markdown>
            - One of the simplest uses of list comprehensions is to make a new list from an old list, while slightly modifying each element along the way
            - Here we're lowercasing all words in our `words` list to make a new `lowercased_words` list
            - Notice there's no condition here... we're just modifying each word, we're not filtering this list at all
          </aside>
        </section>

        <section>
          <h2>Swapping dictionary keys and values</h2>
          <pre class="python"><code data-trim>
flipped_dict = {
    value: key
    for key, value in original_dict.items()
}
          </code></pre>
          <aside class="notes" data-markdown>
            - One use for dictionary comprehensions is to swap keys and values in a dictionary
            - Dictionary keys *have* to be unique, but values don't...
            - If any of the values in this dictionary were the same, we'd get a collision...
            - So you should probably only do something this with when you know that the values in your dictionary are unique
          </aside>
        </section>

        <section>
          <h2>Getting individual digits of an integer</h2>
          <pre class="python"><code data-trim>
number = 4321
digits = [int(d) for d in str(number)]
print digits  # prints [4, 3, 2, 1]
          </code></pre>
          <aside class="notes" data-markdown>
            - Here we're using a list comprehension to loop over digits in an integer
            - We convert the integer to a string, loop over the characters, and then convert each character back to an integer
            - This example might seem a little silly
            - Mostly because a negative sign would mess up this comprehension so this only works for positive integers
            - This is an example to show that we can loop over characters in a string
          </aside>
        </section>

        <section>
          <h2>Turning lists of letters into strings</h2>
          <pre class="python"><code data-trim>
from itertools import permutations

def get_anagrams(word):
    return {
        "".join(letters)
        for letters in permutations(word.lower())
    }
          </code></pre>
          <aside class="notes" data-markdown>
            - We're using permutations to help us find anagrams, both invalid and valid ones
            - We're using `itertools.permutations` to generate all permutations of the letters in a given word
            - Then we're looping over the list of letters that permutations gives us and joining them back together into a string
            - So we'll end up with a set of all anagrams of a given word
          </aside>
        </section>

        <section>
          <h2>Finding all non-repeating letters</h2>
          <pre class="python"><code data-trim>
from collections import Counter

def find_unique_letters(text):
    return {
        char
        for char, count in Counter(text.lower()).items()
        if count == 1
    }
          </code></pre>
          <aside class="notes" data-markdown>
            - Here we're counting the number of occurrences of each character in a string
            - And then making a set of only the characters that occur exactly once
            - So we're using `collections.Counter` on a string and then we're using a set comprehension to get unique letters from that counter object... characters that only have a count of one
            - So we're building up a set of all the unique characters in the given string
          </aside>
        </section>

        <section>
          <h2>Filtering down a list of strings</h2>
          <pre class="python"><code data-trim>
def get_anagrams(target_word, words):
    return [
        candidate_word
        for candidate_word in words
        if is_anagram(candidate_word, target_word)
    ]


def is_anagram(word1, word2):
    """Return True if words contain same letters."""
    return sorted(word1) == sorted(word2)
          </code></pre>
          <aside class="notes" data-markdown>
            - In this example we're using a comprehension to loop through words and check whether each each word is an anagram
            - Note that we're calling a function to do this because `is_anagram` is a lot more descriptive than a comparison of the sorted letters in two words
            - So we're using a list comprehension to filter down our `words` list to a new list of only words that are anagrams of our `target_word`
            - So we're not changing our words at all, just filtering them down to only anagrams
          </aside>
        </section>

        <section>
          <h2>Getting individual digits of an integer</h2>
          <pre class="python"><code data-trim>
negative_matrix = []
for row in matrix:
    new_row = []
    for n in row:
        new_row.append(-n)
    negative_matrix.append(new_row)
          </code></pre>
          <pre class="fragment python"><code data-trim>
negative_matrix = []
for row in matrix:
    negative_matrix.append([-n for n in row])
          </code></pre>
          <pre class="fragment python"><code data-trim>
negative_matrix = [
    [-n for n in row]
    for row in matrix
]
          </code></pre>
          <aside class="notes" data-markdown>
            - This here isn't a comprehension yet
            - This is a `for` loop with a `for` loop inside it
            - We're building up a list of lists
            - That empty `new_row` list and that `new_row.append`... that looks like something we can copy-paste into a comprehension
            - **🖱** So we can copy-paste that inner `for` loop into a comprehension to make things a little simpler
            - Now notice that we have something that also looks like it could be copy-pasted into a comprehension: we have an empty `negative_matrix` list and an `append` in our `for` loop
            - So now we could copy paste the *outer* `for` loop into another comprehension
            - Here we have a list comprehension inside a list comprehension
            - Please only do this sparingly... comprehensions inside of comprehensions don't always improve readability
            - Be cautious when making comprehensions into comprehensions, but know that you can
          </aside>
        </section>

        <section>
          <h2>Conway's Game of Life</h2>
          <pre class="python"><code data-trim>

def still_living(living_cells):
    """Return set of still alive cells after generation."""
    return {
        cell
        for cell in living_cells
        if 2 <= living_neighbors(cell, living_cells) <= 3
    }


def reincarnated(dead_cells, living_cells):
    """Return set of reincarnated cells after generation."""
    return {
        cell
        for cell in dead_cells
        if living_neighbors(cell, living_cells) == 3
    }
          </code></pre>
          <aside class="notes" data-markdown>
            - Here we're using comprehensions to build up sets of neighbors for Conway's game of life
            - If you haven't heard of Conway's game of life, you can look it up afterwards
            - We're filtering all living cells based on the number of living neighbors they currently have
            - We're also filtering all dead cells based on the number of living neighbors they currently have
            - This isn't the entirety of Conway's game of life, but it's a considerable portion of it
            - This is about 25% of my solution for Conway's game of life... I also used generator expressions and set comprehensions for the other portions of my solution
            - ... So we've seen some examples of how to use list, set, and dictionary comprehensions.  Let's finally talk about generators...
          </aside>
        </section>

      </section>

        <!-- This section 5 minutes (not counting examples) -->

      <!-- 10 minute section -->
      <section>

        <section>
          <h2 class="fragment strike">Generator Comprehensions</h2>
          <h2 class="fragment">Generator Expressions</h2>
          <ul>
          <aside class="notes" data-markdown>
            - List comprehensions make lists
            - Set comprehensions make sets
            - Dictionary comprehensions make dictionaries
            - Generator comprehensions make generators
            - Except that they're not actually called generator comprehensions
            - They're called generator expressions
            - Why they're called generator expressions and not generator comprehensions, I don't know... if you say either term people should know what you're talking about
          </aside>
        </section>

        <section>
          <h2>Generator Expressions</h2>
          <ul>
            <li>Generator expressions are to generators as list comprehensions are to lists</li>
            <li>Generators are lazy single-use iterables</li>
            <li class="fragment">If you're making a list to <strong>loop over it exactly once</strong>, use a <strong>generator expression</strong> instead of a list comprehension</li>
          </ul>
          <aside class="notes" data-markdown>
            - You might be wondering what a generator is
            - I'm not going to go too deep into what generators are during this talk because it's a complex topic and that could up an entire talk
            - There's **one thing** I want you to remember about generator expressions
            - If you're writing a list comprehension and you're going to loop over your new list exactly once, you should write a generator expression instead
            - I'll say that again: if you're making a list comprehension and you're going to loop over your list once and only once... use a generator expression instead
            - Alright let's look at how generator expressions work
          </aside>
        </section>

        <section>
          <h2>Generator Expression Syntax</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> numbers = range(1_000_000)
>>> <span class="fragment">squared_numbers = (n ** 2 for n in numbers)
>>> </span><span class="fragment">squared_numbers
&lt;generator object &lt;genexpr> at 0x7f129b187780></span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - If you write a list comprehension and you change the square brackets into parenthesis, you've made a generator expression instead
            - Generator expressions make generators the same way list comprehensions make lists
            - Generators are pretty weird.  Let's take a look at how they behave.
          </aside>
        </section>

        <section>
          <h2>Generators are weird</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> numbers = [1, 2, 3, 4, 5]
>>> squared_numbers = (n ** 2 for n in numbers)
>>> <span class="fragment"><span class="error">len(squared_numbers)
TypeError: object of type 'generator' has no len()</span>
>>> </span><span class="fragment"><span class="error">squared_numbers[0]
TypeError: 'generator' object is not subscriptable</span>
>>> </span><span class="fragment"><span class="success">list(squared_numbers)
[1, 4, 9, 16, 25]</span>
>>> </span><span class="fragment"><span class="warning">list(squared_numbers)
[]</span>
</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Generators don't know how many elements are inside them, so they have no length
            - You can't index generators like you can with lists or tuples
            - The only thing you can do with generators is loop over them
            - And if we loop over generator a second time, we'll get nothing back
            - Generators are a little weird
          </aside>
        </section>

        <section>
          <h2>Generators are lazy</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> from itertools import islice
>>> numbers = range(1_000_000_000)
>>> squared_numbers = (n ** 2 for n in numbers)
<span class="fragment">>>> </span><span class="fragment">next(squared_numbers)
0
>>> </span><span class="fragment">next(squared_numbers)
1
>>> </span><span class="fragment">next(squared_numbers)
4
>>> </span><span class="fragment">next(squared_numbers)
9
>>> </span><span class="fragment">next(squared_numbers)
16</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This generator is squaring all numbers from zero to one billion
            - That would take a long time and could fill up my computers memory
            - But this generator hasn't actually done any work at this point
            - No work will be done until we start looping over this generator object
            - Generators compute items as they go
            - So at this point only the first three items have been computed
            - Generators can be looped over, *just* like lists
            - But they are **lazy**: they only compute values immediately before providing them
          </aside>
        </section>

        <section>
          <h2>Generators are single use iterables</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> numbers = [1, 2, 3, 4, 5]
>>> squared_numbers = (n ** 2 for n in numbers)
<div class="fragment warning">>>> sum(squared_numbers)
333332833333500000
</div><div class="fragment error">>>> sum(squared_numbers)
0</div><div class="fragment">>>> cubed_numbers = (n ** 3 for n in numbers)
<span class="warning">>>> list(cubed_numbers)
[1, 8, 27, 64, 125]</span></div><div class="fragment error">>>> list(cubed_numbers)
[]</div>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Generators are lazy and they're also one-time use only
            - The only thing you can do with generators is loop over them
            - But only once.  The second time you loop a generator, it's empty.
            - Generators are one-time use only
            - Once you've looped over a generator, it's exhausted
            - So generators are lazy and they're single-use
          </aside>
        </section>

        <section>
          <h2>Loop over them right away</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> numbers = range(1_000_000)
<div class="fragment">>>> sum((n ** 2 for n in numbers))
333332833333500000
</div><div class="fragment">>>> sum(n ** 2 for n in numbers)
333332833333500000
</div>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So to be on the safe side, you should loop over a generator as soon as humanly possible
            - Don't even make a variable to store them... just loop
            - The sooner you loop over a generator, the less likely it is that you might accidentally loop over it twice
            - This is such a common thing to do, that Python allows you to remove redundant parenthesis around generators
            - This is probably the most common way to use generators in Python
            - Create it and loop over it right away
            - So you're probably still a little fuzzy on generators at this point, but hopefully you understand that you should create them and then loop over them immediately...
          </aside>
        </section>

        <section>
          <h2>Generator Examples</h2>
          <aside class="notes" data-markdown>
            - Now let's take a look at a couple examples of when you might use a generator expression in your code
          </aside>
        </section>

        <section>
          <h2><code>str.join</code></h2>
          <p>
          <pre class="python"><code data-trim data-noescape>
def translate(sentence):
    translation = []
    for w in sentence.split():
        translation.append(DICTIONARY[w])
    return " ".join(translation)
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def translate(sentence):
    translation = [
        DICTIONARY[w]
        for w in sentence.split()
    ]
    return " ".join(translation)
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def translate(sentence):
    return " ".join(
        DICTIONARY[w]
        for w in sentence.split()
    )
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're looping over a list of words, transforming them, adding them to a new list, and joining them back together with spaces
            - We could use a list comprehension for this
            - but the `join` method on strings accepts any iterable
            - So you can also use join on a generator
            - So here we've moved our list comprehension into the `join` call and removed those brackets to make a generator expression
          </aside>
        </section>

        <section>
          <h2><code>sum</code></h2>
          <p>
          <pre class="python"><code data-trim>
sum_of_squares = 0
for n in numbers:
    sum_of_squares += n**2
          </code></pre>
          <pre class="python fragment"><code data-trim>
squares = []
for n in numbers:
    squares.append(n**2)
sum_of_squares = sum(squares)
          </code></pre>
          <pre class="python fragment"><code data-trim>
sum_of_squares = sum(n**2 for n in numbers)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're looping over numbers and summing up their squares
            - If we wanted to use Python's built-in `sum` function we could refactor this code to use a list
            - This would allow us to copy-paste our way into a list comprehension or a generator expression
            - So we've moved from using += to building up a new list (which seems a little silly) just to use that `sum` function
            - But we can move from this to copy-pasting our way into a generator expression
            - And we end up with this more descriptive code: sum up the squares of each number
          </aside>
        </section>

        <section>
          <h2><code>any</code></h2>
          <p>
          <pre class="python"><code data-trim>
def is_prime(candidate):
    for n in range(2, candidate):
        if candidate % n == 0:
            return False
    return True
          </code></pre>
          <pre class="python fragment"><code data-trim>
def is_prime(candidate):
    divisibility = []
    for n in range(2, candidate):
        divisibility.append(candidate % n == 0)
    return not any(divisibility)
          </code></pre>
          <pre class="python fragment"><code data-trim>
def is_prime(candidate):
    return not any(
        candidate % n == 0
        for n in range(2, candidate)
      )
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're looping over all numbers below a given candidate number and checking whether it has any factors
            - If the number is divisible by any number below it, we immediately return `False`. Otherwise we return `True` because we didn't find any factors so know it must be prime
            - If we wanted to use Python's built-in `any` function we could refactor this code to use a list of `True` and `False` values
            - So here we're using `not any` to make sure this number has no divisors
            - The built-in `any` function in Python returns `True` as soon as it finds a truthy item as it loops... and if everything is `False`, it will `False`
            - This strange `divisibility` list will allow us to copy-paste our way into a generator expression sent directly into `any`
            - That `any` function now will return immediately when it hits a `False` condition... just like our `for` loop did before
          </aside>
        </section>

        <section>
          <h2><code>all</code></h2>
          <p>
          <pre class="python"><code data-trim data-noescape>
def is_prime(candidate):
    for n in range(2, candidate):
        if candidate % n <span class="success">==</span> 0:
            return False
    return True
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def is_prime(candidate):
    non_divisibility = []
    for n in range(2, candidate):
        non_divisibility.append(candidate % n <span class="success">!=</span> 0)
    return all(non_divisibility)
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def is_prime(candidate):
    return all(
        candidate % n <span class="success">!=</span> 0
        for n in range(2, candidate)
      )
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - We're starting with the same code as before here, but we're going to try the same with with the `all` function
            - Notice here we're negating the condition as we loop... this allows us to use `all`
            - If all of these numbers do not evenly divide our candidate number, then our candidate number is prime.
            - Again we can copy-paste our way into a generator expression
            - If any one of these numbers returns `False`, then we know this number is not prime and `all` will immediately return `False`
            - The any and all functions were specially invented to be used alongside generator expressions
          </aside>
        </section>

      </section>

      <!-- 4 minute section -->
      <section>

        <section>
          <h2>When not to use comprehensions</h2>
          <ul>
          <aside class="notes" data-markdown>
            - We've looked at comprehensions and generator expressions
            - And we've seen how to copy-paste your loops into comprehensions
            - But when exactly should you use comprehensions?
            - And is there ever an *inappropriate* time to use a comprehension?
            - Is there ever a time not to use a comprehension?
          </aside>
        </section>

        <section>
          <h2>Don't overdo it</h2>
          <ul>
            <li>Do not call functions with side effects in a comprehension</li>
            <li>Don't use comprehensions except for making lists</li>
            <li>List comprehensions should only be used for turning one list (or iterable) into another list</li>
          </ul>
          <aside class="notes" data-markdown>
            - List comprehensions are **only** useful for turning one list into another
            - Do not use list comprehensions except for making lists
            - Comprehensions should only be used for the specific (but common) use case of turning one list into another list
          </aside>
        </section>

        <section>
          <h2>Don't abuse comprehensions</h2>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
>>> [print(n**2) for n in range(10) if n % 2 == 1]
<span class="fragment">1
9
25
49
81
<span class="error">[None, None, None, None, None]</span></span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're calling `print` function in a comprehension
            - We ended up creating a list of `None` values while we printed things out
            - We really don't care those `None` values... all we care about is the side effect: the printing
            - Do **not** call `print` in a comprehension
            - In fact, don't put any side effects in comprehensions, even if you *are* making a list
            - List comprehensions should only be used for turning one list into another: not for printing
          </aside>
        </section>

        <section>
          <p>
          <pre class="python"><code data-trim>
color_ratios = {}
for color, ratio in zip(colors, ratios):
    color_ratios[color] = ratio
          </code></pre>
          <pre class="python fragment"><code data-trim>
color_ratios = {
    color: ratio
    for (color, ratio) in zip(colors, ratios)
}
          </code></pre>
          <pre class="python fragment"><code data-trim>
color_ratios = dict(zip(colors, ratios))
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're looping over a list of tuples and making a dictionary out of them
            - You might think this would be a good opportunity to use a dictionary comprehension
            - But this isn't the best way to turn a list of tuples into a dictionary
            - The Pythonic way to turn a list of tuples into a dictionary is to use the `dict` construct
            - The `dict` constructor is specially designed for exactly this task
            - There's no reason to re-invent the wheel by doing this ourselves manually
          </aside>
        </section>

        <section>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
with open(filename) as my_file:
    lines = <span class="fragment highlight-red">[line for line in my_file]</span>
          </code></pre>
          <pre class="python fragment"><code data-trim>
with open(filename) as my_file:
    lines = list(my_file)
          </code></pre>
          <pre class="python fragment"><code data-trim>
with open(filename) as my_file:
    lines = my_file.readlines()
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - In this code we're looping over lines in a file and building up a list of them all
            - Whenever you see a comprehension that does no filtering and no modification at all, that should be a red flag
            - The list constructor does exactly this
            - The `list` constructor is usually the Pythonic way to make an iterable into a list
            - But files also have `readlines`, which might be more Pythonic or might be less Pythonic depending on who you ask
            - Just as there are sometimes *simpler* ways to do things than a `for` loop, there are also sometimes simpler ways to do things than a comprehension
          </aside>
        </section>

      </section>

      <!-- 4 minute section -->
      <section>

        <section>
          <h2>Cheat Sheet</h2>
          <aside class="notes" data-markdown>
            I'd like to recap of what we've talked about so far and provide you with a few slides that can hopefully act as a cheat sheet of sorts... to help you figure out when, where, and how to use comprehensions and generator expressions
          </aside>
        </section>

        <section>
          <h2>Building up a new list</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span>:
    <span class="new-collection">new_list</span>.append(<span class="item-mutation">operation(item)</span>)</code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span>
    <span class="item-mutation">operation(item)</span>
    <span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span><span class="collection-type">
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This is a `for` loop that loops over a list of items, does an operation, and appends the result to a new list
            - Whenever you have a `for` loop written in this format you can copy-paste your way into a comprehension
            - This list comprehension is equivalent to that `for` loop
          </aside>
        </section>

        <section>
          <h2>Building up a list while filtering</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span>:
    <span class="conditional-clause">if <span class="condition">condition(item)</span></span>:
        <span class="new-collection">new_list</span>.append(<span class="item-mutation">operation(item)</span>)</code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span>
    <span class="item-mutation">operation(item)</span>
    <span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span><span class="collection-type">
    <span class="conditional-clause">if <span class="condition">condition(item)</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This is a `for` loop that loops over a list of items, checks a condition, does an operation, and appends to a new list every time that condition is true
            - Whenever you have a `for` loop written in *this* format you can also copy-paste your way into a comprehension
            - That comprehension is equivalent to that `for` loop
          </aside>
        </section>

        <section>
          <h2>Building up a new dictionary</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_dict</span> = <span class="collection-type">{}</span>
<span class="for-loop">for <span class="item">key</span>, <span class="item">value</span> in <span class="old-collection">old_dict</span>.items()</span>:
    <span class="conditional-clause">if <span class="condition">condition(key, value)</span></span>:
        <span class="new-collection">new_dict</span>[<span class="item-mutation">change1(key)</span>] = <span class="item-mutation">change2(value)</span></code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_dict</span> = <span class="collection-type">{</span>
    <span class="item-mutation">change1(key)</span>: <span class="item-mutation">change2(value)</span>
    <span class="for-loop">for <span class="item">key</span>, <span class="item">value</span> in <span class="old-collection">old_dict</span>.items()</span>
    <span class="conditional-clause">if <span class="condition">condition(key, value)</span></span>
<span class="collection-type">}</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This is a loop that checks a condition and builds up a dictionary of key-value pairs 
            - This loop is equivalent to this comprehension
            - You can almost copy-paste your way into this... that `key: value` is a little different but it's nearly the same
          </aside>
        </section>

        <section>
          <h2>Looping Deeply</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">inner_list</span> in <span class="old-collection">outer_list</span></span>:
    <span class="nested-for-loop">for <span class="item">item</span> in <span class="old-collection">inner_list</span></span>:
        <span class="new-collection">new_list</span>.append(<span class="item-mutation">item</span>)</code></pre>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span>
    <span class="item-mutation">item</span>
    <span class="for-loop">for <span class="item">inner_list</span> in <span class="old-collection">outer_list</span></span><span class="collection-type">
    <span class="nested-for-loop">for <span class="item">item</span> in <span class="old-collection">inner_list</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This is a nested `for` loop that builds up a new list
            - We're taking a list of lists and converting it to a flattened list
            - Whenever you have code in this format, you can copy-paste it into a comprehension
            - This list comprehension is equivalent to that `for` loop
          </aside>
        </section>

        <section>
          <h2>Not filtering or changing anything?</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span>
    <span class="item-mutation">item</span>
    <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">old_list</span></span><span class="collection-type">
<span class="collection-type">]</span></code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">list</span>(<span class="for-loop"><span class="old-collection">old_list</span></span>)</code></pre>
          </p>
          <aside class="notes" data-markdown>
            - If you're making a new list from an old list without filtering or changing anything, you shouldn't use a list comprehension
            - You should use the `list` constructor
            - The list constructor loops over whatever we give it and builds up a new list out of it
            - It's simplistic but if the simple case is all we need, that's what we should use
          </aside>
        </section>

        <section>
          <h2>Making a list and immediately looping</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span>:
    <span class="new-collection">new_list</span>.append(<span class="item-mutation">operation(item)</span>)
some_result = some_operation(new_list)</code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs">some_result = some_operation(
    <span class="item-mutation">operation(item)</span>
    <span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span>
)</code></pre>
          </p>
          <aside class="notes" data-markdown>
            - If you're making a list and immediately looping over it, you should consider copy-pasting your way into a generator expression
            - Generator expressions look like list comprehensions but they're lazy
            - Generators don't do any work until you start looping over them
            - So we're getting the benefit here of not having to create an unnecessary list just to loop over it once
          </aside>
        </section>

      </section>

      <!-- 1 minute section -->
        <section>
          <h2>Remember</h2>
          <ul>
            <li>Use comprehensions for <strong>turning one iterable into another</strong></li>
            <li><strong>Copy-paste</strong> your way from a for loop to a comprehension</li>
            <li>Use <strong>generators</strong> when you'll be <strong>looping</strong> over your new iterable <strong>only one time</strong></li>
            <li>Break comprehensions and generator expressions over <strong>multiple lines to improve readability</strong></li>
          </ul>
          <aside class="notes" data-markdown>
            - I want you to remember
            - That you can use list comprehensions for turning one iterable into a new list
            - You can use set and dictionary comprehensions for turning an old iterable into a new set or dictionary
            - You can copy-paste your way from a `for` loop to a comprehension
            - If you ever find yourself making a new list just to loop over it once, consider using a generator expression instead of a list comprehension
            - And also remember that you can break your comprehensions over multiple lines to improve readability
          </aside>
        </section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h1>Final</h1>
          <p>
          <small><a href="http://treyhunner.com">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <p>
          <small>
            Python &amp; Django Trainer for hire
            <br>
            <a href="http://truthful.technology">http://truthful.technology</a>
          </small>
          </p>
          <p>
          <img src="logo.svg" class="no-style logo">
          </p>
          <aside class="notes" data-markdown>
            Thank you.

            (I'm happy to bring up a terminal and live code to answer your questions.
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
