<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Comprehensible Comprehensions</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <!-- 2 minute section -->
      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Comprehensible Comprehensions</h1>
          <p>
          <small><a href="https://treyhunner.com" rel="author">Trey Hunner</a> / Python &amp; Django Trainer / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            - I'd like to share with you my love of a particular Python feature that is often misunderstood and misused.
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos"></a>
            <span>On-site training for Django teams</span>
          </div>
          <div class="aboutme-card">
            <a href="http://weeklypython.chat"><img src="pythonchat-logo.png" class="no-style aboutme-logos"></a>
            <span>Weekly Python Chat live webcast host</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonsd.org"><img src="pythonsd-logo.svg" class="no-style aboutme-logos"></a>
            <span>San Diego Python meetup co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="http://djangogirls.org/sandiego"><img src="djangogirls-logo.svg" class="no-style aboutme-logos"></a>
            <span>Django Girls San Diego co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="https://www.python.org/psf-landing/"><img src="psf-logo.png" class="no-style"></a>
            <span>Python Software Foundation director</span>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey.  I help Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - I also host a free live webcast every week on Python-related topics... Unfortunately I *do* usually hold them at 3am in Australia Eastern Standard Time
            - I'm also one of the co-organizers of my local Python meetup in San Diego
            - I've helped organize four Django Girls workshops in Southern California
            - And I'm also one of the 13 directors at the Python Software Foundation
            - Alright that's enough about me.  Let's talk about some assumptions that I'll be making during this talk.
          </aside>
        </section>


        <section>
          <h2>Assumptions</h2>
          <ul>
            <li>You know how <code>for</code> loops work in Python</li>
            <li>You're not already a big fan of list comprehensions and generator expressions</li>
          </ul>
          <aside class="notes" data-markdown>
            - During this talk, I'm assuming you *already* know how `for` loops work in Python
            - I'm also assuming you're **not** already a fan of list comprehensions and generator expressions
            - But I hope by the end of this talk that you'll be a fan of both list comprehensions and generator expressions
          </aside>
        </section>

        <section>
          <h2>Definitions</h2>
          <ul>
            <li><strong>iterable</strong>: anything you can loop over</li>
            <li><strong>list comprehension</strong>: for making a new list from an iterable</li>
            <li><strong>generator</strong>: for making a "lazy" (pause-able) iterable</li>
          </ul>
          <aside class="notes" data-markdown>
            - Let's define some of the words I'm terms to use
            - An **iterable** is anything you can iterate over.  So anything you can loop over with a `for` loop is an iterable.
            - Lists are iterables, dictionaries are iterables, sets are iterables, strings are iterables... lots of things in Python are iterables
            - A **list comprehension** is a special syntax for making a *new* list from any iterable
            - A **generator** is a lazy iterable.  Generators pause and restart themselves repeatedly as you loop over them.
            - A **generator expression** is a special syntax for making a generator
          </aside>
        </section>

        <section>
          <h2>What are comprehensions?</h2>
          <p><blockquote>List comprehensions are a special syntax for turning one list into another list</blockquote></p>
          <aside class="notes" data-markdown>
            - I'll be using all of those terms during this talk, but the term we're *primarily* focused on is **list comprehensions**
            - List comprehensions **do not** solve a new problem...
            - List comprehensions are *special-purpose* tools for solving a problem we're *already* able to solve with `for` loops: turning one list into another list or more generally... transforming an old iterable into a new iterable
          </aside>
        </section>

      </section>

      <!-- 5 minute section -->
      <section>

        <section>
          <h2>Turning Old Lists Into New Lists</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's talk about `for` loops
          </aside>
        </section>

        <section>
          <h2><code>for</code> loops</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = [1, 2, 3, 4, 5]

# Print out square of odd numbers
for n in numbers:
    if n % 2 == 1:
        print(n ** 2)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Python's `for` allows us to loop over any iterable and do things with each item as we loop
            - We can put `if` statements, `print` functions, or pretty much any other code inside our `for` loops
          </aside>
        </section>

        <section>
          <h2>Turning lists into lists</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = [1, 2, 3, 4, 5]

# Populate new list with square of odd numbers
squared_odds = []
for n in numbers:
    if n % 2 == 1:
        squared_odds.append(n ** 2)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This `for` loop makes a new list 
            - Making one list from another list is a *really* common thing to do in Python, even more common than many other programming languages
            - Turning old lists to new lists *is* common in other languages, but it is *particularly* common in Python
            - Why is making new lists from old lists so common in *Python* in particular?
            - I'm going to take a *little aside* here to talk about the reason we turn old lists into new lists so often in Python
          </aside>
        </section>

        <section>
          <h2>Variables Are References</h2>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
>>> old = [1, 2, 3]
>>> new = old
>>> new.pop()
>>> new
[1, 2]
<span class="error">>>> old
[1, 2]</span>

<div class="fragment">>>> old = [1, 2, 3]
>>> new = old[:-1]
>>> new
[1, 2]
<span class="success">>>> old
[1, 2, 3]</span></div>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Assigning to a variable in Python doesn't copy anything
            - Variables in Python are not buckets containing objects
            - Variables are buckets in some languages but that mental model of the world breaks down quickly in Python
            - Variables are simply *references* to objects
            - This can really trip up new Python programmers
            - So we tend to copy old lists to new lists because *mutating* lists is often a bad idea **(click)**
            - When we modify a list, *every* other variable that points to that *same list* will **change as well**
          </aside>
        </section>

        <section>
          <h2>Turning lists into lists</h2>
          <p>
          <pre class="python"><code data-trim>
squared_odds = []
for n in numbers:
    if n % 2 == 1:
        squared_odds.append(n ** 2)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So turning old lists into new lists is a very common thing to do
            - It's such a common thing to do that the Python core developers added a special syntax just for turning one list into another list
            - This special syntax is called a list comprehension
          </aside>
        </section>

        <section>
          <h2>With comprehensions</h2>
          <p>
          <pre class="python"><code data-trim>
squared_odds = [n ** 2 for n in numbers if n % 2 == 1]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This list comprehension is *equivalent* to that `for` loop we wrote before
            - This comprehension is **very** information-dense
            - We've condensed what was *four lines* of code into *one line* here
            - Let's break down our `for` loop and our comprehension to see how they compare
          </aside>
        </section>

        <section>
          <h2>Breaking it down</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span>:
    <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>:
        <span class="new-collection">squared_odds</span>.append(<span class="item-mutation">n ** 2</span>)</code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[</span><span class="item-mutation">n ** 2</span> <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span><span class="collection-type"> <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - I've here highlighted five things in this `for` loop
              - The variable name for our new list is in green
              - The square brackets that make our list are in dark red
              - The looping logic is in purple
              - The condition is in bright red
              - And the item we're appending every time we loop is in blue
            - Here are the same items highlighted in our comprehension **(click)**
            - Notice that our comprehension contains pretty much the same information as our `for` loop except that:
              - we aren't repeating the variable name
              - and we don't have to type append
            - Loops and list comprehensions are *so similar* that you can **copy-paste** your way from a `for` loop to a list comprehension
          </aside>
        </section>

        <section>
          <h2>Copy-pasting into a comprehension</h2>
          <img src="list-comprehension-condition.gif" class="no-style">
          <aside class="notes" data-markdown>
            - To copy-paste our way to a comprehension...
            - We first copy the assignment
            - Then we copy the thing we're appending
            - Then we copy the looping logic
            - Then we copy our condition
            - And after that we've copy pasted our way a `for` loop to a list comprehension
            - So we just need to copy *each* of the components from our `for` loop into a comprehension
            - By copy-pasting our way from a `for` loop, we can build up a comprehension up without actually typing anything new
          </aside>
        </section>

        <section>
          <h2>You can always copy-paste</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">x</span> in <span class="old-collection">old_list</span></span>:
    <span class="conditional-clause">if <span class="condition">condition(x)</span></span>:
        <span class="new-collection">new_list</span>.append(<span class="item-mutation">operation(x)</span>)</code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span><span class="item-mutation">operation(x)</span> <span class="for-loop">for <span class="item">x</span> in <span class="old-collection">old_list</span></span><span class="collection-type"> <span class="conditional-clause">if <span class="condition">condition(x)</span></span>]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here I've highlighted the *same* five things I was highlighting before
            - This is generic code though... it's a blueprint
            - As long as you can figure out a way to write your `for` loop in **this format**, you can *always* **copy-paste** your way from a `for` loop to a comprehension **(click)**
            - So I've shown you how to build a list comprehension from a `for` loop... let's talk about readability
          </aside>
        </section>

      </section>

      <!-- 2 minute section -->
      <section>

        <section>
          <h2>Readability</h2>
          <ul>
          <aside class="notes" data-markdown>
            - The most common complaint about list comprehensions is that they're hard to read
            - List comprehensions take perfectly readable code and make it *less* readable
            - The main reason behind this complaint is that list comprehensions tend to be **much more* **compact** than `for` loops
            - Let's talk about that...
          </aside>
        </section>

        <section>
          <h2>But they're not readable</h2>
          <p>
          <pre class="python"><code data-trim>
for n in numbers:
    if n % 2 == 1:
        squared_odds.append(n ** 2)
          </code></pre>
          <pre class="python"><code data-trim>
squared_odds = [n ** 2 for n in numbers if n % 2 == 1]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Comprehensions are often written *all on one line*
            - *That* is what makes comprehensions hard to read
            - The comprehension here has less *unnecessary information* than the `for` loop, but it also has **less whitespace**
            - That `for` loop has to have white space in it because Python forces us to indent our loops
            - Python doesn't force us to add any spaces at all in our comprehensions... and we've **chosen** not to
          </aside>
        </section>

        <section data-transition="slide-in none-out">
          <h2>Breaking up the components</h2>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[</span><span class="item-mutation">n ** 2</span> <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span><span class="collection-type"> <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>]</span></code></pre>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[</span>
    <span class="item-mutation">n ** 2</span>
    <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span><span class="collection-type">
    <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Comprehensions have 3 parts: the operation, the loop, and the condition **(click)**
            - There is **no reason** that all three of those parts have to be written on **one line of code**
            - In Python, whenever an open bracket, an open brace, or an open parenthesis, you can insert *line breaks* to break one line of code into multiple lines of code **(click)**
            - Breaking comprehensions over multiple lines can make them **much** *more readable*
          </aside>
        </section>

        <section data-transition="none-in slide-out">
          <h2>Breaking up the components</h2>
          <p>
          <pre class="python"><code data-trim>
squared_odds = [n ** 2 for n in numbers if n % 2 == 1]
          </code></pre>
          <pre class="python"><code data-trim>
squared_odds = [
    n ** 2
    for n in numbers
    if n % 2 == 1
]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - In fact, I would argue that breaking up a comprehensions over multiple lines *almost always* improves readability
            - And because of that I would recommend that you start by writing **all** of your your comprehensions over multiple lines and that you *only* combine them into one line if it makes your code more readable
            - Embrace whitespace
            - **Whitespace is your friend**
          </aside>
        </section>

        <section data-transition="slide-in none-out">
          <h2>They can be more readable</h2>
          <p>
          <pre class="python"><code data-trim>
squared_odds = []
for n in numbers:
    if n % 2 == 1:
        squared_odds.append(n ** 2)
          </code></pre>
          <pre class="python"><code data-trim>
squared_odds = [
    n ** 2
    for n in numbers
    if n % 2 == 1
]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Note that this *multi-line* list comprehension has not saved us **any** lines of code
            - In fact, we've gone from **4 lines** of code in our `for` loop to **5 lines** of code in our list comprehension
            - List comprehensions are **not** about saving lines of code
            - List comprehensions are about making our code more **descriptive** and more **readable**
          </aside>
        </section>

        <section data-transition="none-in slide-out">
          <h2>They can be more readable</h2>
          <p>
          <pre class="python"><code data-trim data-noescape>
<span class="blur">squared_odds = []</span>
for <span class="blur">n</span> in <span class="blur">squared_odds</span>:
    <span class="blur">if n % 2 == 1:
        squared_odds.append(n ** 2)</span>
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
squared_odds = [
    <span class="blur">n ** 2</span>
    for <span class="blur">n</span> in <span class="blur">numbers</span>
    <span class="blur">if n % 2 == 1</span>
]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - When a reader looks at the `for` loop above it's *obvious* that we're **looping**... but it may *not immediately* be obvious *why* we're looping
            - When a reader sees our comprehension, it should be *immediately* obvious that **we're creating one list from another list **
            - When we use a list comprehension, we're being more specific with the intent of our code: we are **not just looping**, we're making *one list* out of *another list*
          </aside>
        </section>

      </section>

      <!-- 3 minute section -->
      <section>

        <section>
          <h2>But wait... there's more!</h2>
          <ul>
          <aside class="notes" data-markdown>
            - So I've glossed over a few *important* details in the world of list comprehensions
            - So let's look at a few *other* ways that you can make list comprehensions
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <h2>With Filtering</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span>:
    <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>:
        <span class="new-collection">squared_odds</span>.append(<span class="item-mutation">n ** 2</span>)</code></pre>
          </p>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_odds</span> = <span class="collection-type">[</span>
    <span class="item-mutation">n ** 2</span>
    <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span><span class="collection-type">
    <span class="conditional-clause">if <span class="condition">n % 2 == 1</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So this whole time I've been showing you list comprehensions with **a condition**
            - These list comprehensions *filter out* items that don't match a certain condition
            - You can also write list comprehensions without this `if` statement
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <h2>Without Filtering</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_numbers</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span>:
    <span class="new-collection">squared_numbers</span>.append(<span class="item-mutation">n ** 2</span>)</code></pre>
          </p>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">squared_numbers</span> = <span class="collection-type">[</span>
    <span class="item-mutation">n ** 2</span>
    <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">numbers</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're not *filtering down* our list at all, we're simply changing each item as we add it to our new list
            - So our `for` loop doesn't have an `if` statement and our list comprehension doesn't have a condition of any sort
            - Note that you can still *copy-paste* your way from that `for` loop to this comprehension
            - List comprehensions can be used for filtering, mapping, or both
            - What we saw before was both mapping and filtering
            - But this one here is only mapping old values to new values
          </aside>
        </section>

        <section>
          <h2>With Multiple Loops</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">flattened</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">row</span> in <span class="old-collection">matrix</span></span>:
    <span class="nested-for-loop">for <span class="item">item</span> in <span class="old-collection">row</span></span>:
        <span class="new-collection">flattened</span>.append(<span class="item-mutation">item</span>)</code></pre>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">flattened</span> = <span class="collection-type">[</span>
    <span class="item-mutation">item</span>
    <span class="for-loop">for <span class="item">row</span> in <span class="old-collection">matrix</span></span><span class="collection-type">
    <span class="nested-for-loop">for <span class="item">item</span> in <span class="old-collection">row</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - You can also put *multiple* `for` loops in a comprehension
            - Here we're looping into a list of lists and flattening it into a single list
            - Putting multiple `for` clauses in a comprehension can get a little complicated so *be careful* about using this
            - And if you are going to do this, **definitely** make sure you *break up* your comprehension over **multiple lines**
          </aside>
        </section>

        <section>
          <h2>Set comprehensions</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = {1, 2, 3, 4, 5}

squared_odds = set()
for n in numbers:
    if n % 2 == 1:
        squared_odds.add(n ** 2)
          </code></pre>
          <pre class="python"><code data-trim>
numbers = {1, 2, 3, 4, 5}

squared_odds = {
    n ** 2
    for n in numbers
    if n % 2 == 1
}
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Comprehensions aren't just limited to lists... there are also set comprehensions
            - Just as a list comprehension builds up a new list, a set comprehension builds up a new set
            - Set comprehensions are functionally equivalent to adding items to a set over and over in a loop (just as list comprehensions are functionally equivalent to appending items to a list over and over)
          </aside>
        </section>

        <section>
          <h2>Dictionary comprehensions</h2>
          <p>
          <pre class="python"><code data-trim>
from string import ascii_lowercase

letter_positions = {}
for n, letter in enumerate(ascii_lowercase, start=1):
    letter_positions[letter] = n
          </code></pre>
          <pre class="python"><code data-trim>
from string import ascii_lowercase

letter_positions = {
    letter: n
    for n, letter in enumerate(ascii_lowercase, start=1)
}
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So there's set comprehensions... there's also dictionary comprehensions in Python
            - List comprehensions make lists, set comprehensions make sets, and dictionary comprehensions make dictionaries
            - Just as *sets* and *dictionaries* have a **similar syntax**, *dictionary comprehensions* and *set comprehensions* have a **similar syntax**
            - Dictionary comprehensions use **curly braces** the same way that set comprehensions do
            - But *unlike* set comprehensions they **need a colon** in-between key-value pairs to build up the dictionary
            - Unlike list comprehensions, I **always** break my dictionary comprehensions over multiple lines
          </aside>
        </section>

      </section>

      <!-- 0 minute section -->
      <section>

        <section>
          <h2>Examples</h2>
          <aside class="notes" data-markdown>
            - So I've shown you the syntax of list, set, and dictionary comprehensions
            - Let's take a look at some slightly more realistic examples of list, set, and dictionary comprehensions
          </aside>
        </section>

        <section>
          <h2>Modifying each item in a list</h2>
          <pre class="python"><code data-trim>
lowercased_words = [word.lower() for word in words]
          </code></pre>
          <aside class="notes" data-markdown>
            - One of the simplest uses of list comprehensions is to make a new list from an old list, while slightly modifying each element along the way
            - Here we're lowercasing all words in our `words` list to make a new `lowercased_words` list
            - Notice there's no condition here... we're just modifying each word, we're not filtering this list at all
          </aside>
        </section>

        <section>
          <h2>Filtering down a list of strings</h2>
          <pre class="python"><code data-trim>
def get_anagrams(target_word, words):
    return [
        candidate_word
        for candidate_word in words
        if is_anagram(candidate_word, target_word)
    ]


def is_anagram(word1, word2):
    """Return True if words contain same letters."""
    return sorted(word1) == sorted(word2)
          </code></pre>
          <aside class="notes" data-markdown>
            - In this example we're using a comprehension to loop through words and check whether each each word is an anagram
            - Note that we're calling a function to do this because `is_anagram` is a lot more descriptive than a comparison of the sorted letters in two words
            - So we're using a list comprehension to filter down our `words` list to a new list of only words that are anagrams of our `target_word`
            - So we're not changing our words at all, just filtering them down to only anagrams
          </aside>
        </section>

        <section>
          <h2>Modifying a list of lists</h2>
          <pre class="python"><code data-trim>
negative_matrix = []
for row in matrix:
    new_row = []
    for n in row:
        new_row.append(-n)
    negative_matrix.append(new_row)
          </code></pre>
          <pre class="fragment python"><code data-trim>
negative_matrix = []
for row in matrix:
    negative_matrix.append([-n for n in row])
          </code></pre>
          <pre class="fragment python"><code data-trim>
negative_matrix = [
    [-n for n in row]
    for row in matrix
]
          </code></pre>
          <aside class="notes" data-markdown>
            - This here isn't a comprehension yet
            - This is a `for` loop with a `for` loop inside it
            - We're building up a list of lists
            - That empty `new_row` list and that `new_row.append`... that looks like something we can copy-paste into a comprehension
            - **(click)** So we can copy-paste that inner `for` loop into a comprehension to make things a little simpler
            - Now notice that we have something that also looks like it could be copy-pasted into a comprehension: we have an empty `negative_matrix` list and an `append` in our `for` loop
            - So now we could copy paste the *outer* `for` loop into another comprehension **(click)**
            - Here we have a list comprehension inside a list comprehension
            - Please only do this sparingly... comprehensions inside of comprehensions don't always improve readability
            - Be cautious when making comprehensions into comprehensions, but know that you can
          </aside>
        </section>

      </section>

      <!-- 7 minute section -->
      <section>

        <section>
          <h2 class="fragment strike">Generator Comprehensions</h2>
          <h2 class="fragment">Generator Expressions</h2>
          <ul>
          <aside class="notes" data-markdown>
            - List comprehensions make lists
            - Set comprehensions make sets
            - Dictionary comprehensions make dictionaries
            - Generator comprehensions make generators
            - Except that they're not actually called generator comprehensions **(click)**
            - They're called generator expressions **(click)**
            - Why they're called generator expressions and not generator comprehensions, I don't know... if you say either term people *should* know what you're talking about
            - So we have generator comprehensions but we call them generator expressions
          </aside>
        </section>

        <section>
          <h2>Generator Expressions</h2>
          <ul>
            <li>Generator expressions are to generators as list comprehensions are to lists</li>
            <li>Generators are lazy single-use iterables</li>
            <li class="fragment">If you're making a list to <strong>loop over it exactly once</strong>, use a <strong>generator expression</strong> instead of a list comprehension</li>
          </ul>
          <aside class="notes" data-markdown>
            - You might be wondering what a generator is
            - I'm not going to go too deep into *what generators are* during this talk because it's a complex topic and that could up **an entire talk** all on its own
            - There is **one thing** I want you to remember about generator expressions
            - If you're writing a list comprehension and you're going to loop over your new list exactly once, you should write a generator expression *instead* **(click)**
            - I'll say that again: if you're making a list comprehension and you're going to loop over your list once and **only once**... use a generator expression instead of a list comprehension
            - Alright... let's look at how generator expressions work
          </aside>
        </section>

        <section>
          <h2>Generator Expression Syntax</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> numbers = range(1_000_000)
>>> <span class="fragment">squared_numbers = (n ** 2 for n in numbers)
>>> </span><span class="fragment">squared_numbers
&lt;generator object &lt;genexpr> at 0x7f129b187780></span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - If you write a list comprehension and you change the **square brackets** into **parenthesis**, you've made a generator expression instead **(click)**
            - Generator expressions make generators the same way list comprehensions make lists **(click)**
            - Generators are pretty weird though *(pause)*
          </aside>
        </section>

        <section>
          <h2>Generators are weird</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> numbers = [1, 2, 3, 4, 5]
>>> squared_numbers = (n ** 2 for n in numbers)
>>> <span class="fragment"><span class="error">len(squared_numbers)
TypeError: object of type 'generator' has no len()</span>
>>> </span><span class="fragment"><span class="error">squared_numbers[0]
TypeError: 'generator' object is not subscriptable</span>
>>> </span><span class="fragment"><span class="success">list(squared_numbers)
[1, 4, 9, 16, 25]</span>
>>> </span><span class="fragment"><span class="warning">list(squared_numbers)
[]</span>
</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Generators don't know how many elements are inside them, so they have **no length** **(click)**
            - You can't **index** generators like you can with lists or tuples **(click)**
            - The only thing you can do with generators is **loop over them** **(click)**
            - And if we loop over generator **a second time**, we'll get **nothing back** **(click)**
            - Generators are a little weird
          </aside>
        </section>

        <section>
          <h2>Generators are lazy</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> from itertools import islice
>>> numbers = range(1_000_000_000)
>>> squared_numbers = (n ** 2 for n in numbers)
<span class="fragment">>>> </span><span class="fragment">next(squared_numbers)
0
>>> </span><span class="fragment">next(squared_numbers)
1
>>> </span><span class="fragment">next(squared_numbers)
4
>>> </span><span class="fragment">next(squared_numbers)
9
>>> </span><span class="fragment">next(squared_numbers)
16</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This generator is squaring all numbers from zero to one billion
            - That would take a long time and could fill up my computers memory
            - But this generator hasn't actually done any work at this point
            - No work will be done until we start looping over this generator object **(click)**
            - Generators compute items as they go **(click)**
            - So at this point only the first **(click)** three items have been computed
            - Generators can be looped over, *just* like lists **(click)**
            - But they are **lazy**: they only compute values immediately before providing them
          </aside>
        </section>

        <section>
          <h2>Generators are single use iterables</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> numbers = [1, 2, 3, 4, 5]
>>> squared_numbers = (n ** 2 for n in numbers)
<div class="fragment warning">>>> sum(squared_numbers)
333332833333500000
</div><div class="fragment error">>>> sum(squared_numbers)
0</div><div class="fragment">>>> cubed_numbers = (n ** 3 for n in numbers)
<span class="warning">>>> list(cubed_numbers)
[1, 8, 27, 64, 125]</span></div><div class="fragment error">>>> list(cubed_numbers)
[]</div>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Generators are *lazy* and they're also *one-time use only*
            - The *only* thing you can do with generators is loop over them **(click)**
            - But **only once**.  The second time you loop over a generator, it's empty. **(click)**
            - Generators are one-time use only **(click)**
            - Once you've fully looped over a generator, we say it's exhausted **(click)**
            - So generators are **lazy** and they're **single-use**
          </aside>
        </section>

        <section>
          <h2>Loop over them right away</h2>
          <p>
          <pre class="no-highlight "><code class="hljs" data-trim data-noescape>
>>> numbers = range(1_000_000)
<div class="fragment">>>> sum((n ** 2 for n in numbers))
333332833333500000
</div><div class="fragment">>>> sum(n ** 2 for n in numbers)
333332833333500000
</div>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So to be on the safe side, you should loop over a generator as soon as humanly possible
            - Don't even make a variable to store them... *just loop* **(click)**
            - The *sooner* you loop over a generator, the *less likely* it is that you might *accidentally* **loop over it twice**
            - This is *such* a common thing to do, that Python allows you to **remove redundant parenthesis** around generators **(click)**
            - This is probably the *most common* way to use generators in Python
            - Create it and *loop over it right away*
            - So you're probably still a little fuzzy on generators at this point, but hopefully you understand that after you create them, you should loop over them immediately...
          </aside>
        </section>

        <section>
          <h2>Generator Examples</h2>
          <aside class="notes" data-markdown>
            - Now let's take a look at a couple examples of when you might use a generator expression in your code
          </aside>
        </section>

        <section>
          <h2><code>str.join</code></h2>
          <p>
          <pre class="python"><code data-trim data-noescape>
def translate(sentence):
    translation = []
    for w in sentence.split():
        translation.append(DICTIONARY[w])
    return " ".join(translation)
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def translate(sentence):
    translation = [
        DICTIONARY[w]
        for w in sentence.split()
    ]
    return " ".join(translation)
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def translate(sentence):
    return " ".join(
        DICTIONARY[w]
        for w in sentence.split()
    )
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're looping over a list of words, transforming them, adding them to a new list, and joining them back together with spaces
            - We could use a list comprehension for this **(click)**
            - but the `join` method on strings accepts any iterable
            - So you can also use join on a generator **(click)**
            - So here we've moved our list comprehension into the `join` call and removed those brackets to make a generator expression
          </aside>
        </section>

        <section>
          <h2><code>sum</code></h2>
          <p>
          <pre class="python"><code data-trim>
sum_of_squares = 0
for n in numbers:
    sum_of_squares += n**2
          </code></pre>
          <pre class="python fragment"><code data-trim>
squares = []
for n in numbers:
    squares.append(n**2)
sum_of_squares = sum(squares)
          </code></pre>
          <pre class="python fragment"><code data-trim>
sum_of_squares = sum(n**2 for n in numbers)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're looping over numbers and summing up their squares
            - If we wanted to use Python's built-in `sum` function we could refactor this code to use a list **(click)**
            - This would allow us to copy-paste our way into a list comprehension or a generator expression
            - So we've moved from using += to building up a new list (which seems a little silly) just to use that `sum` function
            - But we can move from this to copy-pasting our way into a generator expression **(click)**
            - And we end up with this more descriptive code: sum up the squares of each number
          </aside>
        </section>

      </section>

      <!-- 4 minute section -->
      <section>

        <section>
          <h2>When not to use comprehensions</h2>
          <ul>
          <aside class="notes" data-markdown>
            - We've looked at comprehensions and generator expressions
            - And we've seen how to **copy-paste** your loops into comprehensions
            - But when exactly should you *use* comprehensions?
            - And is there ever an *inappropriate* time to use a comprehension?
            - Is it ever a *bad* idea to use comprehensions?
          </aside>
        </section>

        <section>
          <h2>Don't overdo it</h2>
          <ul>
            <li>Do not call functions with side effects in a comprehension</li>
            <li>Don't use comprehensions except for making lists</li>
            <li>List comprehensions should only be used for turning one list (or iterable) into another list</li>
          </ul>
          <aside class="notes" data-markdown>
            - List comprehensions are **only** useful for turning one list into another
            - Do not use list comprehensions *except for making lists*
            - Comprehensions should only be used for the **specific (but common)** use case of *turning one list into another list*
          </aside>
        </section>

        <section>
          <h2>Don't abuse comprehensions</h2>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
>>> [print(n**2) for n in range(10) if n % 2 == 1]
<span class="fragment">1
9
25
49
81
<span class="error">[None, None, None, None, None]</span></span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're calling the `print` function in a comprehension **(click)**
            - We ended up creating a list of `None` values while we printed things out
            - We really **don't care** those `None` values... all we care about is **the side effect**: the printing
            - Do **not** call `print` in a comprehension
            - In fact, don't put *any side effects* in comprehensions, even if you *are* making a list
            - List comprehensions should only be used for turning one list into another: not for printing
          </aside>
        </section>

        <section>
          <p>
          <pre class="python"><code data-trim>
color_ratios = {}
for color, ratio in zip(colors, ratios):
    color_ratios[color] = ratio
          </code></pre>
          <pre class="python fragment"><code data-trim>
color_ratios = {
    color: ratio
    for (color, ratio) in zip(colors, ratios)
}
          </code></pre>
          <pre class="python fragment"><code data-trim>
color_ratios = dict(zip(colors, ratios))
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're looping over a list of tuples and making a dictionary out of them
            - You might think this would be a good opportunity to use a dictionary comprehension **(click)** *(pause)*
            - But this isn't the best way to turn a list of tuples into a dictionary
            - The Pythonic way to turn a list of tuples into a dictionary is to use the `dict` construct **(click)**
            - The `dict` constructor is *specially designed* for **exactly this task**
            - There is no reason to *re-invent the wheel* by doing this ourselves manually
          </aside>
        </section>

        <section>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
with open(filename) as my_file:
    lines = <span class="fragment highlight-red">[line for line in my_file]</span>
          </code></pre>
          <pre class="python fragment"><code data-trim>
with open(filename) as my_file:
    lines = list(my_file)
          </code></pre>
          <pre class="python fragment"><code data-trim>
with open(filename) as my_file:
    lines = my_file.readlines()
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - In this code we're looping over lines in a file and putting them all into a new list
            - Whenever you see a comprehension that does **no filtering** and **no modification** at all, that should be a red flag **(click)**
            - The list constructor does **exactly this**
            - The `list` constructor is *usually* the Pythonic way to copy an iterable into a new list **(click)**
            - You **don't** need to make a list comprehension when you're not *changing* anything in your iterable
            - But files also have a `readlines` method, which might be *more Pythonic* or might be *less Pythonic* depending on who you ask **(click)**
            - Personally I prefer that middle approach, but that's just me *(pause)*
            - Just as there are sometimes *simpler* ways to do things than a `for` loop, there are also sometimes simpler ways to do things than a comprehension
          </aside>
        </section>

      </section>

      <!-- 4 minute section -->
      <section>

        <section>
          <h2>Cheat Sheet</h2>
          <aside class="notes" data-markdown>
            - I have a little visual review here of everything we've just gone through
            - I'm going to run through these slides quickly but you can review them later and use these slides as a cheat sheet to help you figure out when, where, and how to use comprehensions and generator expressions
          </aside>
        </section>

        <section>
          <h2>Building up a new list</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span>:
    <span class="new-collection">new_list</span>.append(<span class="item-mutation">operation(item)</span>)</code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span>
    <span class="item-mutation">operation(item)</span>
    <span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span><span class="collection-type">
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This is a `for` loop that loops over a list of items, does an operation, and appends the result to a new list
            - Whenever you have a `for` loop written in this format you can copy-paste your way into a comprehension **(click)**
            - This list comprehension is equivalent to that `for` loop
          </aside>
        </section>

        <section>
          <h2>Building up a list while filtering</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span>:
    <span class="conditional-clause">if <span class="condition">condition(item)</span></span>:
        <span class="new-collection">new_list</span>.append(<span class="item-mutation">operation(item)</span>)</code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span>
    <span class="item-mutation">operation(item)</span>
    <span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span><span class="collection-type">
    <span class="conditional-clause">if <span class="condition">condition(item)</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This `for` loop is the same as before, except that we're checking a condition to filter our new list as we build it up
            - Whenever you have a `for` loop written in *this* format you can also copy-paste your way into a comprehension **(click)**
            - That comprehension is equivalent to that `for` loop
          </aside>
        </section>

        <section>
          <h2>Building up a new dictionary</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_dict</span> = <span class="collection-type">{}</span>
<span class="for-loop">for <span class="item">key</span>, <span class="item">value</span> in <span class="old-collection">old_dict</span>.items()</span>:
    <span class="conditional-clause">if <span class="condition">condition(key, value)</span></span>:
        <span class="new-collection">new_dict</span>[<span class="item-mutation">change1(key)</span>] = <span class="item-mutation">change2(value)</span></code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_dict</span> = <span class="collection-type">{</span>
    <span class="item-mutation">change1(key)</span>: <span class="item-mutation">change2(value)</span>
    <span class="for-loop">for <span class="item">key</span>, <span class="item">value</span> in <span class="old-collection">old_dict</span>.items()</span>
    <span class="conditional-clause">if <span class="condition">condition(key, value)</span></span>
<span class="collection-type">}</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This is a loop that checks a condition and builds up a dictionary of key-value pairs 
            - This loop is equivalent to this comprehension **(click)**
            - You can almost copy-paste your way into this... that `key: value` is a little different but it's nearly the same
          </aside>
        </section>

        <section>
          <h2>Looping Deeply</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">inner_list</span> in <span class="old-collection">outer_list</span></span>:
    <span class="nested-for-loop">for <span class="item">item</span> in <span class="old-collection">inner_list</span></span>:
        <span class="new-collection">new_list</span>.append(<span class="item-mutation">item</span>)</code></pre>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span>
    <span class="item-mutation">item</span>
    <span class="for-loop">for <span class="item">inner_list</span> in <span class="old-collection">outer_list</span></span><span class="collection-type">
    <span class="nested-for-loop">for <span class="item">item</span> in <span class="old-collection">inner_list</span></span>
<span class="collection-type">]</span></code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This is a nested `for` loop that builds up a new list
            - We're taking a list of lists and converting it to a flattened list
            - Whenever you have code in this format, you can copy-paste it into a comprehension **(click)**
            - This list comprehension is equivalent to that `for` loop
          </aside>
        </section>

        <section>
          <h2>Not filtering or changing anything?</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[</span>
    <span class="item-mutation">item</span>
    <span class="for-loop">for <span class="item">n</span> in <span class="old-collection">old_list</span></span><span class="collection-type">
<span class="collection-type">]</span></code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">list</span>(<span class="for-loop"><span class="old-collection">old_list</span></span>)</code></pre>
          </p>
          <aside class="notes" data-markdown>
            - If you're making a new list from an old list without filtering or changing anything, you shouldn't use a list comprehension
            - You should use the `list` constructor **(click)**
            - The list constructor loops over whatever we give it and builds up a new list out of it
            - It's simplistic but if the simple case is all we need, that's what we should use
          </aside>
        </section>

        <section>
          <h2>Making a list and immediately looping</h2>
          <p>
          <pre class="no-highlight colored-comprehension"><code data-noescape class="hljs"><span class="new-collection">new_list</span> = <span class="collection-type">[]</span>
<span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span>:
    <span class="new-collection">new_list</span>.append(<span class="item-mutation">operation(item)</span>)
some_result = some_operation(new_list)</code></pre>
          </p>
          <p>
          <pre class="fragment no-highlight colored-comprehension"><code data-noescape class="hljs">some_result = some_operation(
    <span class="item-mutation">operation(item)</span>
    <span class="for-loop">for <span class="item">item</span> in <span class="old-collection">old_list</span></span>
)</code></pre>
          </p>
          <aside class="notes" data-markdown>
            - If you're making a list and immediately looping over it, you should consider copy-pasting your way into a generator expression **(click)**
            - Generator expressions look like list comprehensions but they're lazy
            - Generators don't do any work until you start looping over them
            - So we're getting the benefit here of not having to create an unnecessary list just to loop over it once
          </aside>
        </section>

      </section>

      <!-- 1 minute section -->
        <section>
          <h2>Remember</h2>
          <ul>
            <li>Use comprehensions for <strong>turning one iterable into another</strong></li>
            <li><strong>Copy-paste</strong> your way from a for loop to a comprehension</li>
            <li>Use <strong>generators</strong> when you'll be <strong>looping</strong> over your new iterable <strong>only one time</strong></li>
            <li>Break comprehensions and generator expressions over <strong>multiple lines to improve readability</strong></li>
          </ul>
          <aside class="notes" data-markdown>
            - I want you to remember
            - That you can use list comprehensions for loop over an iterable while building up a new list from it
            - You can use *set* and *dictionary* comprehensions for turning an old iterable into a new set or dictionary
            - And if you have a `for` loop is written in the right format, you can **copy-paste** your way from a `for` loop to a comprehension
            - If you ever find yourself making a new list just to loop over it once, consider using a **generator expression** instead of a *list comprehension*
            - And also please please remember to *break* your comprehensions over **multiple lines** to improve the readability of your code
          </aside>
        </section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h3>Things to look up later</h3>
          <ul>
            <li><a href="https://www.youtube.com/watch?v=_AEJHKGk9ns">Facts and Myths about Python names and values</a></li>
            <li><a href="https://www.youtube.com/watch?v=u8g9scXeAcI">Looping Like a Pro in Python</a></li>
            <li><a href="https://www.youtube.com/watch?v=JYuE8ZiDPl4">Loop better: a deeper look at iteration in Python</a></li>
            <li><a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">Python List Comprehensions: Explained Visually</a></li>
          </ul>
          <p>
          <small><a href="http://treyhunner.com">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <p>
          <small>
            Python &amp; Django Trainer for hire
            <br>
            <a href="http://truthful.technology">http://truthful.technology</a>
          </small>
          </p>
          <p>
          <img src="logo.svg" class="no-style logo">
          </p>
          <aside class="notes" data-markdown>
            Thank you.
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
